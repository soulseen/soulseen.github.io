[{"title":"创建TLS证书和密钥","url":"/2019/04/06/创建TLS证书和密钥/","content":"\n### 前言\n\n&emsp;这一步是在安装配置kubernetes的所有步骤中最容易出错也最难于排查问题的一步，而这却刚好是第一步，万事开头难，不要因为这点困难就望而却步。\n\n&emsp;接下去的命令操作虽然非常简单，但是如果不想云里雾里的执行命令，完全不了解自已在做什么的情况下进行部署，建议先阅读[ 基于CA根证书签名的双向数字证书认证方式介绍](<https://soulseen.github.io/2019/04/05/%E5%9F%BA%E4%BA%8ECA%E6%A0%B9%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/>)。\n\n&emsp;`kubernetes` 系统的各组件需要使用 `TLS` 证书对通信进行加密，本文档使用 `CloudFlare` 的 PKI 工具集 [cfssl](https://github.com/cloudflare/cfssl) 来生成 Certificate Authority (CA) 和其它证书；最后生成的CA证书和密钥文件如下：\n\n```shell\n$ ls /etc/kubernetes/ssl/\nadmin-key.pem  admin.pem  ca-key.pem  ca.pem  kube-proxy-key.pem  kube-proxy.pem  kubernetes-key.pem  kubernetes.pem\n```\n\n密钥和证书的操作只需在master上操作即可。\n\n### 安装CFSSL\n\n直接使用二进制源码包进行安装：\n\n```shell\nwget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64\nchmod +x cfssl_linux-amd64\nmv cfssl_linux-amd64 /usr/local/bin/cfssl\n\nwget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64\nchmod +x cfssljson_linux-amd64\nmv cfssljson_linux-amd64 /usr/local/bin/cfssljson\n\nwget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64\nchmod +x cfssl-certinfo_linux-amd64\nmv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfo\n\nexport PATH=/usr/local/bin:$PATH\n```\n\n### 创建CA\n\n**创建CA配置文件**\n\n```shell\n\nmkdir /root/ssl\ncd /root/ssl\ncfssl print-defaults config > config.json\ncfssl print-defaults csr > csr.json\n# 根据config.json文件的格式创建如下的ca-config.json文件\n# 过期时间设置成了 87600h\ncat > ca-config.json <<EOF\n{\n  \"signing\": {\n    \"default\": {\n      \"expiry\": \"87600h\"\n    },\n    \"profiles\": {\n      \"kubernetes\": {\n        \"usages\": [\n            \"signing\",\n            \"key encipherment\",\n            \"server auth\",\n            \"client auth\"\n        ],\n        \"expiry\": \"87600h\"\n      }\n    }\n  }\n}\nEOF\n```\n\n字段说明\n\n- `ca-config.json`：可以定义多个 profile，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；\n- `signing`：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 `CA=TRUE`；\n- `server auth`：表示client可以用该 CA 对server提供的证书进行验证；\n- `client auth`：表示server可以用该CA对client提供的证书进行验证；\n\n**创建 CA 证书签名请求**\n\n创建 `ca-csr.json` 文件，内容如下：\n\n```json\n{\n  \"CN\": \"kubernetes\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ],\n    \"ca\": {\n       \"expiry\": \"87600h\"\n    }\n}\n```\n\n- \"CN\"：`Common Name`，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；\n- \"O\"：`Organization`，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；\n\n**生成 CA 证书和私钥**\n\n```shell\n$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca\n$ ls ca*\nca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem\n```\n\n### 创建admin证书\n\n创建 admin 证书签名请求文件 `admin-csr.json`：\n\n```json\n{\n  \"CN\": \"admin\",\n  \"hosts\": [],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"system:masters\",\n      \"OU\": \"System\"\n    }\n  ]\n}\n```\n\n**注意**：这个admin 证书，是将来生成管理员用的kube config 配置文件用的，现在我们一般建议使用RBAC 来对kubernetes 进行角色权限控制， kubernetes 将证书中的CN 字段 作为User， O 字段作为 Group\n\n生成 admin 证书和私钥：\n\n```shell\n$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin\n$ ls admin*\nadmin.csr  admin-csr.json  admin-key.pem  admin.pem\n```\n\n## 创建 kube-proxy 证书\n\n创建 kube-proxy 证书签名请求文件 `kube-proxy-csr.json`：\n\n```json\n{\n  \"CN\": \"system:kube-proxy\",\n  \"hosts\": [],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ]\n}\n```\n\n- CN 指定该证书的 User 为 `system:kube-proxy`；\n- `kube-apiserver` 预定义的 RoleBinding `system:node-proxier` 将User `system:kube-proxy` 与 Role `system:node-proxier` 绑定，该 Role 授予了调用 `kube-apiserver` Proxy 相关 API 的权限；\n\n生成 kube-proxy 客户端证书和私钥\n\n```bash\n$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy\n$ ls kube-proxy*\nkube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem\n```\n\n证书创建完成后可使用`opsnssl`命令对证书进行校验，最后将将生成的证书和秘钥文件（后缀名为`.pem`）拷贝到所有机器的 `/etc/kubernetes/ssl` 目录下备用。\n\n```bash\nmkdir -p /etc/kubernetes/ssl\ncp *.pem /etc/kubernetes/ssl\n```\n\n","tags":["k8w"]},{"title":"基于CA根证书签名的双向数字证书认证方式介绍","url":"/2019/04/05/基于CA根证书签名的双向数字证书认证方式介绍/","content":"\n&emsp;&emsp;Kubernetes集群中所有资源的访问方式和变更都是通过Kubernetes API Server的REST API来实现的，所以集群安全的关键点就在于如何识别并认证客户端身份(Authentication)，以及随后访问权限的授权(Authorization)这两个关键问题。\n\n&emsp;&emsp;Kubernetes一共提供了3中级别的客户端身份认证方式。\n\n- HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式介绍\n- HTTP Token认证：通过Token来识别合法用户\n- HTTP Base认证：通过用户名和密码认证\n\n&emsp;本次搭建使用的是CA认证，相比于其余二中更加可靠，但是也更加难于理解。\n\n&emsp;首先需要有一个CA证书，CA是PKI系统中通信双方都信任的实体，作为可信第三方存在(TTP)。CA首先必须让用户信任，并且让能信任者追究自己的责任。CA主要通过证书证实他人的公钥信息，证书上也有CA的签名。也正是因为CA承担责任的承诺，被称为可信第三方。通常情况下，CA与用户是相互独立的，CA作为服务提供方，也可能会因为数据有误而给用户带来损失。在证书中绑定了公钥数据和拥有用户的相关身份信息，并带有CA的数字签名，也包含了CA的名称信息。\n\n&emsp;CA涉及到的概念比较多，比如根证书、自签名证书、密钥、私钥等。下面主要写SSL协议的流程，以便更好的理解CA认证和Kubernetes CA认证。\n\n&emsp;关于SSL(Secure Socket Laye)，首先举个例子。我有一个箱子，一把锁和一把钥匙，我把箱子和开着的锁可以给任何需要给我写信的人，他写了信放箱子里，锁上，然后传递回我手上的途中谁都打不开箱子，只有我可以用原来的钥匙打开，这就是SSL，公钥，私钥传递加密消息的方式。\n\n&emsp;推荐一篇不错的文章，《**[SSL Certificates HOWTO](<http://www.tldp.org/HOWTO/SSL-Certificates-HOWTO/x64.html>)**》，其中介绍了详细介绍了SSL的具体流程，以及对公钥、私钥、加密、证书等的相关解释。\n\n&emsp;其中CA认证可大致理解为一下几个步骤:\n\n1、HTTPS通信的双方向CA申请证书，CA机构下发根证书、服务端证书以及私钥给申请者。\n\n2、客户端向服务器端发起请求，服务端下发服务端证书给客户端。客户端接收到证书后，通过私钥解密证书，通过解密得到的公钥、服务端域名等信息的校验，如果一致，客户端则认可服务器端。\n\n3、客户端发送客户端证书给服务器端，服务端收到证书后，同样对其解密，并获得客户端证书公钥，用其认证证书信息，确认客户端合法。\n\n4、客户端通过公钥来加密一个随机的对称密钥，并发送该随机密钥到服务器端，服务器端收到后，双方通信的所有内容都通过该随机密钥加密。\n\n&emsp;在k8s集群中，有一个集群根证书颁发机构(CA)。集群中的组件通常使用CA来验证API server的证书，由API服务器验证kubelet客户端证书等。为了支持这一点，CA证书包被分发到集群中的每个节点，并作为一个secret附加分发到默认service account上。\n\n\n\n","tags":["k8s，CA认证"]},{"title":"二进制部署Etcd高可用版Kubernetes","url":"/2019/04/05/二进制部署Etcd高可用版Kubernetes/","content":"\n### 说明\n\n​\t本环境介绍使用二进制的方式部署 `kubernetes` 集群的所有步骤，其中高可用部署`Etcd`，以便让初学者更好的理解K8s的鉴权、系统各组件的交互原理等，进而能快速解决实际问题。若想快速部署一个k8s集群可使用minikube或者kubeadm。\n\n### 前提条件\n\n​\t1、科学上网\n\n​\t2、节点配置情况：\n\n|      node       |      ip      | cpu/mem |\n| :-------------: | :----------: | :-----: |\n| k8s-1-1(master) | 192.168.0.19 |  2核4G  |\n|  k8s-1-2(node)  | 192.168.0.20 |  2核4G  |\n|  k8s-1-3(node)  | 192.168.0.3  |  2核4G  |\n\n​\t操作系统版本：CentOS Linux release 7.5.1804 (Core),\n\n### 安装前准备\n\n​\t1、在所有节点上安装Docker CE ，安装方式请参考[Get Docker CE for CentOS](<https://docs.docker.com/install/linux/docker-ce/centos/#prerequisites>)\n\n​\t2、关闭所有节点的SELinux，修改`/etc/selinux/config`文件中设置SELINUX=disabled ，然后重启服务器。\n\n​\t3、关闭交换分区，swapoff -a \n\n​\t4、关闭防火墙，systemctl stop firewalld && systemctl disable firewalld\n\n### 安装步骤介绍\n\n0、[基于CA根证书签名的双向数字证书认证方式介绍](<https://soulseen.github.io/2019/04/05/%E5%9F%BA%E4%BA%8ECA%E6%A0%B9%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/>)\n\n1、创建TLS证书和密钥\n\n2、安装bukectl命令行工具\n\n3、创建kubeconfig文件\n\n4、搭建高可用Etcd集群\n\n5、部署master节点\n\n6、安装flannel网络插件\n\n7、部署node节点\n\n8、安装kebedns\n\n各种插件选装\n\n未完待续。。。"}]